---
// Canvas-based road animation component for the homepage
---

<canvas id="road-canvas" class="road-canvas"></canvas>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('road-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Get hero image for alignment (solid snake gif)
    const heroImage = document.querySelector('.hero-image');
    if (!heroImage) return;

    // Get footer for detecting where road should end
    const footer = document.querySelector('footer');
    if (!footer) return;

    // Resize canvas to fill the viewport
    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Gruvbox dark colors
    const colors = {
      bg0: '#282828', // Dark background
      bg1: '#3c3836', // Slightly lighter background
      bg2: '#504945', // Lighter background
      bg3: '#665c54', // Lightest background
      bg4: '#7c6f64', // Lightest greys
      fg: '#ebdbb2',  // Normal foreground
      fg2: '#d5c4a1', // Darker foreground
      fg3: '#bdae93', // Even darker foreground
      yellow: '#ebdbb2', // Accent color for road markings (changed from #fabd2f to #ebdbb2)
      green: '#b8bb26'  // Alternative accent color
    };

    // Animation settings
    let roadSpeed = -5; // Negative means stripes moving toward viewer - increased speed

    // Adjust speed based on character size and screen height
    function updateRoadSpeed() {
      const heroImg = document.querySelector('.hero-image');
      if (heroImg) {
        const rect = heroImg.getBoundingClientRect();
        // Set a faster speed for more dramatic motion
        roadSpeed = -Math.max(4, Math.min(6, rect.height / 30));
      }
    }
    updateRoadSpeed();

    // Track if animation should be active
    let animationActive = true;

    // Check if we're at the footer and should stop animation
    function checkFooterVisibility() {
      if (!footer) return;
      const footerRect = footer.getBoundingClientRect();
      // If footer is in view, gradually slow down the animation
      if (footerRect.top < window.innerHeight) {
        const visibleRatio = (window.innerHeight - footerRect.top) / footerRect.height;
        animationActive = visibleRatio < 0.8; // Stop completely when footer is 80% visible
        // Gradually slow down as footer becomes visible
        if (animationActive && visibleRatio > 0) {
          roadSpeed = roadSpeed * (1 - visibleRatio);
        }
      } else {
        animationActive = true;
      }
    }

    // Calculate perspective points and road segments
    let segments = [];
    let segmentSpacing = 120; // Default spacing that will be adjusted

    // Add side elements for more depth perception
    let sideElements = [];
    const numSideElements = 12; // Number of elements on each side

    // Create side elements for enhanced depth perception
    function initSideElements() {
      sideElements = [];
      // Create different side elements with varied shapes/sizes for both sides
      for (let i = 0; i < numSideElements; i++) {
        // Left side elements
        sideElements.push({
          side: 'left',
          y: Math.random() * window.innerHeight,
          size: 4 + Math.random() * 8,
          color: i % 3 === 0 ? colors.green : colors.fg3,
          shape: i % 4 // 0: circle, 1: square, 2: triangle, 3: dash
        });

        // Right side elements
        sideElements.push({
          side: 'right',
          y: Math.random() * window.innerHeight,
          size: 4 + Math.random() * 8,
          color: i % 3 === 0 ? colors.green : colors.fg3,
          shape: i % 4
        });
      }
    }

    // Initialize road segments with spacing based on character size
    function initSegments() {
      const heroImg = document.querySelector('.hero-image');
      if (heroImg) {
        // Adjust segment spacing based on character size
        const rect = heroImg.getBoundingClientRect();
        // Create more frequent road markings for better animation
        segmentSpacing = Math.max(40, rect.height * 0.5); // Shorter spacing for more frequent stripes
      }

      segments = [];
      // Create evenly spaced segments from vanishing point to bottom
      const footer = document.querySelector('footer');
      const bottomY = footer ? footer.getBoundingClientRect().top : window.innerHeight;
      const vanishingPointY = window.innerHeight * 0.05;

      // Calculate number of segments needed to fill the road
      const roadHeight = bottomY - vanishingPointY;
      const numSegments = Math.ceil(roadHeight / segmentSpacing) + 2; // Add extra segments for smooth scrolling

      // Create segments with precise spacing
      for (let i = 0; i < numSegments; i++) {
        segments.push(vanishingPointY + (i * segmentSpacing));
      }

      // Initialize side elements
      initSideElements();
    }

    initSegments();

    // Main animation function
    function animate() {
      // Check if we're at the footer and should stop/slow animation
      checkFooterVisibility();

      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Get character position from the GIF image (ninja)
      const rect = heroImage.getBoundingClientRect();
      const characterX = window.innerWidth / 2; // Center horizontally
      const characterY = rect.bottom - 5; // Position just below character's feet

      // Calculate vanishing point based on character position
      // Place vanishing point higher above the character for more dramatic perspective
      const vanishingPointY = Math.max(window.innerHeight * 0.05, characterY - Math.min(rect.height * 3, window.innerHeight * 0.4));

      // Calculate road width proportionally to character size
      const charWidth = rect.width;
      // Make the road narrower at vanishing point for stronger perspective
      const roadWidthAtVP = Math.max(15, charWidth * 0.2); 

      // Make road wider at bottom for stronger perspective effect
      const roadWidthAtBottom = Math.min(window.innerWidth * 0.5, charWidth * 5);

      // Calculate road dimensions
      const roadHeight = characterY - vanishingPointY;
      const roadWidthAtTop = roadWidthAtVP;
      // Wider road at bottom of screen creates more dramatic perspective
      const roadWidthAtScreenBottom = roadWidthAtBottom * 1.4; 

      // Get the footer position to determine where road should visually end
      const footerRect = footer.getBoundingClientRect();
      // Draw road background - adjust to end at footer if visible
      const bottomY = Math.min(window.innerHeight, footerRect.top);

      // Use solid color for road instead of gradient for cleaner look
      ctx.fillStyle = colors.bg1; // Use a single solid color
      ctx.beginPath();
      ctx.moveTo(characterX - roadWidthAtTop / 2, vanishingPointY); // Top left
      ctx.lineTo(characterX + roadWidthAtTop / 2, vanishingPointY); // Top right
      ctx.lineTo(characterX + roadWidthAtScreenBottom / 2, bottomY); // Bottom right
      ctx.lineTo(characterX - roadWidthAtScreenBottom / 2, bottomY); // Bottom left
      ctx.closePath();
      ctx.fill();

      // Add subtle road texture (horizontal lines for asphalt effect)
      const textureCount = 40;
      ctx.globalAlpha = 0.03; // Very subtle
      for (let i = 0; i < textureCount; i++) {
        const y = vanishingPointY + (bottomY - vanishingPointY) * (i / textureCount);
        const progressToBottom = i / textureCount;
        const lineWidth = roadWidthAtTop + progressToBottom * (roadWidthAtScreenBottom - roadWidthAtTop);

        ctx.beginPath();
        ctx.moveTo(characterX - lineWidth / 2, y);
        ctx.lineTo(characterX + lineWidth / 2, y);
        ctx.strokeStyle = i % 2 === 0 ? colors.bg0 : colors.bg3;
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;

      // Draw road edges with solid color for cleaner look
      ctx.strokeStyle = colors.yellow; // Use solid yellow for edges
      ctx.lineWidth = 2.5; // Thicker line for better visibility

      // Left edge
      ctx.beginPath();
      ctx.moveTo(characterX - roadWidthAtTop / 2, vanishingPointY);
      ctx.lineTo(characterX - roadWidthAtScreenBottom / 2, bottomY);
      ctx.stroke();

      // Right edge
      ctx.beginPath();
      ctx.moveTo(characterX + roadWidthAtTop / 2, vanishingPointY);
      ctx.lineTo(characterX + roadWidthAtScreenBottom / 2, bottomY);
      ctx.stroke();

      // Add center line divider
      // Draw a dashed center line
      if (animationActive) {
        // Create center segments for the dashed line
        const dashLength = segmentSpacing * 0.5;
        const gapLength = dashLength * 0.5;
        const totalLength = dashLength + gapLength;

        // Calculate how many dashes we need to fill the road
        const numDashes = Math.ceil((bottomY - vanishingPointY) / totalLength) + 1;

        for (let i = 0; i < numDashes; i++) {
          // Calculate position based on animation frame
          const baseY = vanishingPointY + ((roadSpeed * 0.2 + i * totalLength) % (totalLength * numDashes));

          // Only draw if within visible road area
          if (baseY >= vanishingPointY && baseY <= bottomY) {
            // Calculate progress from vanishing point to bottom
            const t = (baseY - vanishingPointY) / (bottomY - vanishingPointY);

            // Calculate width at this position
            const lineWidthAtPos = roadWidthAtTop + t * (roadWidthAtScreenBottom - roadWidthAtTop);

            // Calculate dash length based on perspective
            const perspectiveDashLength = dashLength * (0.1 + t * 0.9);

            // Draw center line
            ctx.beginPath();
            ctx.moveTo(characterX, baseY);
            ctx.lineTo(characterX, baseY + perspectiveDashLength);
            ctx.strokeStyle = colors.yellow;
            ctx.lineWidth = 2 + 3 * t; // Thicker at bottom for perspective
            ctx.stroke();
          }
        }
      }

      // Removed shadow effect for cleaner animation

      // Draw roadside elements to enhance depth perception
      if (animationActive) {
        for (let i = 0; i < sideElements.length; i++) {
          // Update side element position with consistent speed
          sideElements[i].y += roadSpeed * 0.8; // More consistent speed, less random variation
          if (sideElements[i].y > bottomY) {
            sideElements[i].y = vanishingPointY;
            sideElements[i].size = 4 + Math.random() * 8;
          }

          // Calculate position on the road edge with perspective
          const t = (sideElements[i].y - vanishingPointY) / (bottomY - vanishingPointY);
          const sideWidth = roadWidthAtTop + t * (roadWidthAtScreenBottom - roadWidthAtTop);
          const sideX = characterX + (sideElements[i].side === 'left' ? -sideWidth/2 - sideElements[i].size/2 : sideWidth/2 + sideElements[i].size/2);

          // Size increases with distance from vanishing point
          const perspectiveSize = sideElements[i].size * (0.2 + t * 0.8);

          // Only draw if between vanishing point and bottom
          if (sideElements[i].y >= vanishingPointY && sideElements[i].y <= bottomY) {
            ctx.fillStyle = sideElements[i].color;

            // Draw different shapes based on the element type
            switch(sideElements[i].shape) {
              case 0: // Circle
                ctx.beginPath();
                ctx.arc(sideX, sideElements[i].y, perspectiveSize/2, 0, Math.PI * 2);
                ctx.fill();
                break;
              case 1: // Square
                ctx.fillRect(
                  sideX - perspectiveSize/2,
                  sideElements[i].y - perspectiveSize/2,
                  perspectiveSize,
                  perspectiveSize
                );
                break;
              case 2: // Triangle
                ctx.beginPath();
                ctx.moveTo(sideX, sideElements[i].y - perspectiveSize/2);
                ctx.lineTo(sideX + perspectiveSize/2, sideElements[i].y + perspectiveSize/2);
                ctx.lineTo(sideX - perspectiveSize/2, sideElements[i].y + perspectiveSize/2);
                ctx.closePath();
                ctx.fill();
                break;
              case 3: // Dash
                ctx.fillRect(
                  sideX - perspectiveSize,
                  sideElements[i].y - perspectiveSize/4,
                  perspectiveSize * 2,
                  perspectiveSize/2
                );
                break;
            }
          }
        }
      }

      // Draw the moving road stripes/segments
      if (animationActive) {
        for (let i = 0; i < segments.length; i++) {
          // Update segment position
          segments[i] += roadSpeed; // Use consistent roadSpeed

          // Fix the wrapping logic to ensure proper movement
          if (segments[i] > bottomY) {
            segments[i] = vanishingPointY;
          } else if (segments[i] < vanishingPointY) {
            segments[i] = bottomY;
          }

          // Calculate interpolation factor (t=0 at vanishing point, t=1 at bottom)
          const t = (segments[i] - vanishingPointY) / (bottomY - vanishingPointY);

          // Calculate position using interpolation
          const yPos = segments[i];

          // Only draw segments that are between the vanishing point and bottom
          if (yPos >= vanishingPointY && yPos <= bottomY) {
            // Calculate width at this y-position (interpolate from top to bottom)
            const segmentProgress = (yPos - vanishingPointY) / (bottomY - vanishingPointY);

            // Adjust segment size for perspective - proportional to road width
            const roadWidthAtThisPoint = roadWidthAtTop + segmentProgress * (roadWidthAtBottom - roadWidthAtTop);

            // Road stripe dimensions - longer for more visible stripes
            const segmentWidth = Math.max(8, roadWidthAtThisPoint * 0.2); // Wider for better visibility
            const segmentHeight = Math.max(4, roadWidthAtThisPoint * 0.03); // Slightly taller

            // Use the updated yellow color (ebdbb2) for road stripes with no opacity for better contrast
            ctx.fillStyle = colors.yellow; // Now using #ebdbb2

            // Draw two parallel stripes for a more road-like appearance
            // Left stripe
            ctx.fillRect(
              characterX - (roadWidthAtThisPoint * 0.25), // Position at 1/4 from center
              yPos - segmentHeight / 2, // Center vertically
              segmentWidth,
              segmentHeight
            );

            // Right stripe
            ctx.fillRect(
              characterX + (roadWidthAtThisPoint * 0.25) - segmentWidth, // Position at 1/4 from center
              yPos - segmentHeight / 2, // Center vertically
              segmentWidth,
              segmentHeight
            );
          }
        }
      }

      // Removed vignette effect for cleaner animation

      // Continue animation if active
      if (animationActive) {
        requestAnimationFrame(animate);
      } else {
        // Check periodically if we should resume animation
        setTimeout(() => requestAnimationFrame(animate), 500);
      }
    }

    // Start animation
    animate(); // Initial call to start the animation loop

    // Handle resize and scroll
    window.addEventListener('resize', () => {
      resizeCanvas();
      updateRoadSpeed(); // Recalculate speed based on new character size
      initSegments(); // Reset segments with new spacing
    });

    window.addEventListener('scroll', () => {
      checkFooterVisibility(); // Check if footer is visible to adjust animation
    });
  });
</script>

<style>
  .road-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1; /* Keep low to ensure other elements appear above */
    touch-action: none; /* Prevent touch scrolling */
    -webkit-user-select: none; /* Prevent selection */
    user-select: none;
    image-rendering: pixelated; /* Makes road edges crisper */
  }

  /* Create perspective for the hero image with shadow */
  :global(.hero-image) {
    filter: drop-shadow(0 10px 8px rgba(0, 0, 0, 0.5));
    transform-origin: bottom center;
    /* Use much more subtle animation for the GIF */
    animation: snake-move 1s infinite alternate ease-in-out;
  }

  @keyframes snake-move {
    from { transform: translateY(0); }
    to { transform: translateY(-2px); }
  }

  @media (prefers-reduced-motion: reduce) {
    .road-canvas {
      display: none;
    }

    :global(.hero-image) {
      animation: none;
      filter: none;
    }
  }
</style>
