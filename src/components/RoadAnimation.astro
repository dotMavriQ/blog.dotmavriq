---
// RoadAnimation.astro
// Improved, stable implementation for Astro — inspired by the deployed (hoisted) runtime
---

<canvas id="road-canvas" class="road-canvas"></canvas>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('road-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const hero = document.querySelector('.hero-image');
    const footer = document.querySelector('footer');
    if (!hero || !footer) return;

    // Resize helper
    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    resizeCanvas();

    // Cache hero geometry to avoid per-frame jitter
    let heroRect = hero.getBoundingClientRect();
    let cachedCharX = heroRect.left + heroRect.width / 2;
    let cachedCharY = heroRect.bottom - 5;
    let cachedCharW = heroRect.width;
    let cachedVanishingY = Math.max(window.innerHeight * 0.05, cachedCharY - Math.min(cachedCharW * 3, window.innerHeight * 0.4));

    function updateHeroCache() {
      heroRect = hero.getBoundingClientRect();
      cachedCharX = heroRect.left + heroRect.width / 2;
      cachedCharY = heroRect.bottom - 5;
      cachedCharW = heroRect.width;
      cachedVanishingY = Math.max(window.innerHeight * 0.05, cachedCharY - Math.min(cachedCharW * 3, window.innerHeight * 0.4));
    }

    // Colors
    const colors = {
      bg0: '#282828',
      bg1: '#3c3836',
      bg2: '#504945',
      bg3: '#665c54',
      bg4: '#7c6f64',
      fg: '#ebdbb2',
      fg2: '#d5c4a1',
      fg3: '#bdae93',
      yellow: '#ebdbb2',
      green: '#b8bb26'
    };

    // Animation parameters (tweak for feel)
    let roadSpeed = -5; // negative -> stripes move toward vanishing point
    function updateRoadSpeed() {
      const r = hero.getBoundingClientRect();
      roadSpeed = -Math.max(4, Math.min(6, r.height / 30));
    }
    updateRoadSpeed();

    // Reduced-motion respect
    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReduced) {
      // disable animation entirely
      canvas.style.display = 'none';
      return;
    }

    // Footer visibility check
    let animationActive = true;
    function checkFooterVisibility() {
      const f = footer.getBoundingClientRect();
      if (f.top < window.innerHeight) {
        const visibleRatio = (window.innerHeight - f.top) / f.height;
        animationActive = visibleRatio < 0.8;
        if (animationActive && visibleRatio > 0) {
          // Slow animation progressively
          roadSpeed = roadSpeed * (1 - visibleRatio);
        }
      } else {
        animationActive = true;
      }
    }

    // Segments and side elements
    let segments = [];
    let segmentSpacing = 120;
    const sideElements = [];
    const sideCount = 12;

    function initSideElements() {
      sideElements.length = 0;
      for (let i = 0; i < sideCount; i++) {
        sideElements.push({ side: 'left', y: Math.random() * window.innerHeight, size: 4 + Math.random() * 8, color: i % 3 === 0 ? colors.green : colors.fg3, shape: i % 4 });
        sideElements.push({ side: 'right', y: Math.random() * window.innerHeight, size: 4 + Math.random() * 8, color: i % 3 === 0 ? colors.green : colors.fg3, shape: i % 4 });
      }
    }

    function initSegments() {
      const r = hero.getBoundingClientRect();
      // Denser center dashes for stronger motion perception
      segmentSpacing = Math.max(40, r.height * 0.5);

      segments = [];
      const footerRect = footer.getBoundingClientRect();
      const bottomY = footerRect ? footerRect.top : window.innerHeight;
      const vanishingY = cachedVanishingY || window.innerHeight * 0.05;

      const roadHeight = bottomY - vanishingY;
      const numSegments = Math.ceil(roadHeight / segmentSpacing) + 2;
      for (let i = 0; i < numSegments; i++) segments.push(vanishingY + i * segmentSpacing);

      initSideElements();
    }

    initSegments();

    // Main draw loop
    function animate() {
      checkFooterVisibility();

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Use cached hero geometry (stable)
      const cx = Math.round(window.innerWidth / 2);
      const cy = Math.round(cachedCharY);
      const vanishingY = Math.max(window.innerHeight * 0.05, cachedVanishingY);
      const charW = cachedCharW;
      const roadTopW = Math.max(15, charW * 0.2);
      const roadBottomW = Math.min(window.innerWidth * 0.5, charW * 5);
      const roadScreenBottomW = roadBottomW * 1.4;

      const footerRect = footer.getBoundingClientRect();
      const bottomY = Math.min(window.innerHeight, footerRect.top);

      // Draw filled road polygon (keeps parity with deployed animation)
      ctx.fillStyle = colors.bg1;
      ctx.beginPath();
      ctx.moveTo(cx - roadTopW / 2, vanishingY);
      ctx.lineTo(cx + roadTopW / 2, vanishingY);
      ctx.lineTo(cx + roadScreenBottomW / 2, bottomY);
      ctx.lineTo(cx - roadScreenBottomW / 2, bottomY);
      ctx.closePath();
      ctx.fill();

      // Subtle road texture
      const textureCount = 40;
      ctx.globalAlpha = 0.03;
      for (let i = 0; i < textureCount; i++) {
        const y = vanishingY + (bottomY - vanishingY) * (i / textureCount);
        const prog = i / textureCount;
        const widthAt = roadTopW + prog * (roadScreenBottomW - roadTopW);
        ctx.beginPath();
        ctx.moveTo(cx - widthAt / 2, y);
        ctx.lineTo(cx + widthAt / 2, y);
        ctx.strokeStyle = i % 2 === 0 ? colors.bg0 : colors.bg3;
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Road edges
      ctx.strokeStyle = colors.yellow;
      ctx.lineWidth = 2.5;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(cx - roadTopW / 2, vanishingY);
      ctx.lineTo(cx - roadScreenBottomW / 2, bottomY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx + roadTopW / 2, vanishingY);
      ctx.lineTo(cx + roadScreenBottomW / 2, bottomY);
      ctx.stroke();

      // Center dashes (from deployed behavior) — draw short vertical strokes spaced by totalLength
      if (animationActive) {
        const dashLen = segmentSpacing * 0.5;
        const gap = dashLen * 0.5;
        const totalLen = dashLen + gap;
        const num = Math.ceil((bottomY - vanishingY) / totalLen) + 1;

        for (let s = 0; s < num; s++) {
          const base = vanishingY + ((roadSpeed * 0.2 + s * totalLen) % (totalLen * num));
          if (base >= vanishingY && base <= bottomY) {
            const t = (base - vanishingY) / (bottomY - vanishingY);
            const widthAt = roadTopW + t * (roadScreenBottomW - roadTopW);
            const pDash = dashLen * (0.1 + t * 0.9);
            ctx.beginPath();
            ctx.moveTo(cx, base);
            ctx.lineTo(cx, base + pDash);
            ctx.strokeStyle = colors.yellow;
            ctx.lineWidth = 2 + 3 * t;
            ctx.stroke();
          }
        }
      }

      // Side elements
      if (animationActive) {
        for (let i = 0; i < sideElements.length; i++) {
          sideElements[i].y += roadSpeed * 0.8;
          if (sideElements[i].y > bottomY) {
            sideElements[i].y = vanishingY;
            sideElements[i].size = 4 + Math.random() * 8;
          }

          const t = (sideElements[i].y - vanishingY) / (bottomY - vanishingY);
          const sideWidth = roadTopW + t * (roadScreenBottomW - roadTopW);
          const sideX = cx + (sideElements[i].side === 'left' ? -sideWidth / 2 - sideElements[i].size / 2 : sideWidth / 2 + sideElements[i].size / 2);
          const size = sideElements[i].size * (0.2 + t * 0.8);

          if (sideElements[i].y >= vanishingY && sideElements[i].y <= bottomY) {
            ctx.fillStyle = sideElements[i].color;
            switch (sideElements[i].shape) {
              case 0:
                ctx.beginPath();
                ctx.arc(sideX, sideElements[i].y, size / 2, 0, Math.PI * 2);
                ctx.fill();
                break;
              case 1:
                ctx.fillRect(sideX - size / 2, sideElements[i].y - size / 2, size, size);
                break;
              case 2:
                ctx.beginPath();
                ctx.moveTo(sideX, sideElements[i].y - size / 2);
                ctx.lineTo(sideX + size / 2, sideElements[i].y + size / 2);
                ctx.lineTo(sideX - size / 2, sideElements[i].y + size / 2);
                ctx.closePath();
                ctx.fill();
                break;
              case 3:
                ctx.fillRect(sideX - size, sideElements[i].y - size / 4, size * 2, size / 2);
                break;
            }
          }
        }
      }

      // Moving stripe segments (parallel stripes) — driven by segments array
      if (animationActive) {
        // Checkered mid-line (inspired by RoadAnimation.tsx)
        // Move segments upward (toward vanishing point) and wrap
        const baseSpeed = Math.abs(roadSpeed) || 4;
        for (let i = 0; i < segments.length; i++) {
          // Move upward: subtract positive amount
          segments[i] += roadSpeed; // roadSpeed is negative; keeps existing behavior
          if (segments[i] < vanishingY) segments[i] += (bottomY - vanishingY);
          else if (segments[i] > bottomY) segments[i] -= (bottomY - vanishingY);

          const yPos = segments[i];
          if (yPos >= vanishingY && yPos <= bottomY) {
            // Perspective factor (0 at vanishing point, 1 at bottom)
            const t = (yPos - vanishingY) / (bottomY - vanishingY);

            // Interpolate size for perspective — similar to TSX formula
            const minSegW = 5;
            const minSegH = 2;
            const segW = Math.max(minSegW, (1 - t) * 20 + 5);
            const segH = Math.max(minSegH, (1 - t) * 10 + 2);

            // Compute x position: centerish but slightly biased toward vanishing point for perspective
            const xPos = cx; // keep center aligned with hero

            // Alternate colors for checkered effect
            const checkColor = (i % 2 === 0) ? colors.fg : colors.bg3;
            ctx.fillStyle = checkColor;

            ctx.fillRect(Math.round(xPos - segW / 2), Math.round(yPos - segH / 2), Math.round(segW), Math.round(segH));
          }
        }
      }

      // Optional subtle grunge overlay (like TSX)
      ctx.fillStyle = 'rgba(0,0,0,0.04)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Top fade overlay
      try {
        const fadeTop = 0;
        const fadeBottom = Math.max(0, vanishingY);
        const grad = ctx.createLinearGradient(0, fadeTop, 0, fadeBottom);
        grad.addColorStop(0, colors.bg0);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = grad;
        ctx.fillRect(0, fadeTop, canvas.width, fadeBottom);
        ctx.restore();
      } catch (e) {
        // ignore
      }

      if (animationActive) requestAnimationFrame(animate);
      else setTimeout(() => requestAnimationFrame(animate), 500);
    }

    // Start loop
    requestAnimationFrame(animate);

    // Recompute caches and layout on resize
    window.addEventListener('resize', () => {
      resizeCanvas();
      updateHeroCache();
      updateRoadSpeed();
      initSegments();
    });

    // Footer visibility listener
    window.addEventListener('scroll', checkFooterVisibility);
  });
</script>

<style>
  .road-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1; /* hero GIF kept above */
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    image-rendering: pixelated;
  }

  :global(.hero-image) {
    filter: drop-shadow(0 10px 8px rgba(0,0,0,0.5));
    transform-origin: bottom center;
    animation: snake-move 1s infinite alternate ease-in-out;
    z-index: 20;
  }

  @keyframes snake-move { from { transform: translateY(0); } to { transform: translateY(-2px); } }

  @media (prefers-reduced-motion: reduce) {
    .road-canvas { display: none; }
    :global(.hero-image) { animation: none; filter: none; }
  }
</style>
