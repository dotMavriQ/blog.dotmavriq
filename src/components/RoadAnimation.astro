---
// RoadAnimation.astro
// Minimal, reliable single-canvas road animation:
// - Two edge lines (no fill) aimed at the hero "hips"
// - Moving checkered center line to suggest forward motion
// - Uses devicePixelRatio scaling to be sharp
// - ResizeObserver keeps geometry in sync
// - Canvas is under page content (low z-index) and pointer-events disabled
---

<canvas id="road-canvas" class="road-canvas" aria-hidden="true"></canvas>

<script>
  // @ts-nocheck
  // Provide ambient declaration for tooling (ignored at runtime)
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  /**
   * @typedef {Object} RoadAnimationAPI
   * @property {() => void} stop
   * @property {() => void} start
   * @property {() => { w:number, h:number, heroRect:DOMRect, segmentsCount:number }} info
   */
  document.addEventListener("DOMContentLoaded", () => {
    /** @type {HTMLCanvasElement | null} */
    const canvas = document.getElementById("road-canvas");
    if (!canvas) return;
    /** @type {CanvasRenderingContext2D | null} */
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const win = /** @type {any} */ (window);

    // Respect prefers-reduced-motion
    if (
      window.matchMedia &&
      window.matchMedia("(prefers-reduced-motion: reduce)").matches
    ) {
      canvas.style.display = "none";
      return;
    }

    canvas.style.pointerEvents = "none";

    let dpr = Math.max(1, window.devicePixelRatio || 1);
    let w = 0,
      h = 0;

    function setSize() {
      dpr = Math.max(1, window.devicePixelRatio || 1);
      w = Math.max(1, window.innerWidth);
      h = Math.max(1, window.innerHeight);
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    setSize();
    window.addEventListener("resize", setSize);

    // Hero element; fallback if not present
    function getHeroRect() {
      const el = document.querySelector(".hero-image");
      if (!el) {
        const size = Math.min(180, Math.max(120, w * 0.18));
        return {
          left: (w - size) / 2,
          top: h * 0.35,
          width: size,
          height: size,
          bottom: h * 0.35 + size,
        };
      }
      return el.getBoundingClientRect();
    }

    let heroRect = getHeroRect();

    // Keep heroRect current
    if (window.ResizeObserver) {
      const heroEl = document.querySelector(".hero-image");
      if (heroEl) {
        new ResizeObserver(() => {
          heroRect = heroEl.getBoundingClientRect();
        }).observe(heroEl);
      }
    }

    // Road geometry helpers
    const leftX = () => Math.round(w * 0.14);
    const rightX = () => Math.round(w * 0.86);
    const bottomY = () => Math.round(h - 2);

    // Center-line segments enhanced: each segment is an object with motion & styling variance.
    // u: progression (0 top / vanishing point, 1 bottom near camera)
    // speed: per-segment travel speed multiplier
    // wobblePhase/wobbleSpeed: for subtle lateral oscillation (running camera bounce)
    // offsetX: static lateral dispersion factor to break straight line (scaled by perspective)
    // lenFactor: variation in dash length
    /** @type {{u:number,speed:number,wobblePhase:number,wobbleSpeed:number,offsetX:number,lenFactor:number}[]} */
    let segments = [];
    const gapU = 0.09; // base spacing
    const EXTRA = 8; // extra segments so recycling feels continuous

    function makeSegment(baseU) {
      return {
        u: baseU,
        speed: 0.55 + Math.random() * 0.9,
        wobblePhase: Math.random() * Math.PI * 2,
        wobbleSpeed: 1.2 + Math.random() * 1.8,
        offsetX: (Math.random() - 0.5) * 0.22, // relative lateral offset
        lenFactor: 0.7 + Math.random() * 0.7,
      };
    }

    function initSegments() {
      segments = [];
      const count = Math.ceil(1 / gapU) + EXTRA;
      for (let i = 0; i < count; i++) segments.push(makeSegment((i * gapU) % 1));
    }
    initSegments();

    // Animation state
    let last = performance.now();
    let running = true;

    function animate(now) {
      if (!running) return;
      const dt = Math.min(40, now - last) / 1000; // seconds
      last = now;

      // update sizes in case of change
      heroRect = getHeroRect();

      // vanishing point ("hips") - slightly above bottom of hero
      const vpX = (heroRect.left || 0) + (heroRect.width || 0) / 2;
      const vpY = (heroRect.bottom || h * 0.55) - (heroRect.height || 0) * 0.32;

      // clear
      ctx.clearRect(0, 0, w, h);

      // draw road edges (stroked lines, no fill)
      const edgeWidth = Math.max(2, (heroRect.width || 120) * 0.02);
      ctx.lineWidth = edgeWidth;
      ctx.lineCap = "round";
      ctx.strokeStyle = "rgba(220,200,150,0.98)";

      ctx.beginPath();
      ctx.moveTo(leftX(), bottomY());
      ctx.lineTo(vpX - Math.max(12, (heroRect.width || 120) * 0.12), vpY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(rightX(), bottomY());
      ctx.lineTo(vpX + Math.max(12, (heroRect.width || 120) * 0.12), vpY);
      ctx.stroke();

      // Center guide line â€“ recolored to blend with dark background (#282828) per request
      ctx.strokeStyle = "#282828";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(Math.round(w / 2), bottomY());
      ctx.lineTo(vpX, vpY);
      ctx.stroke();

      // Animate center dashes
      // Further slowed down & perspective adjusted (bottom large -> top small)
  const speedPx = Math.max(10, (heroRect.width || 120) * 0.35); // baseline speed (per segment multiplier applied later)
      // convert to parameter-space speed (approx): when u moves from 0 to 1, y goes from vpY to bottom
      const approxLength = bottomY() - vpY;
      const speedU = (speedPx * dt) / Math.max(approxLength, 1);

      const time = now / 1000;
      const cameraBob = Math.sin(time * 2.1) * 0.015 + Math.sin(time * 0.9 + 1.2) * 0.012;

      for (let i = 0; i < segments.length; i++) {
        const seg = segments[i];
        // move upward (towards vanishing point)
        seg.u -= speedU * seg.speed;
        if (seg.u < 0) {
          // recycle at bottom maintaining residual (so spacing stays smooth) and randomize traits
            const recycledU = seg.u + 1;
            Object.assign(seg, makeSegment(recycledU));
            seg.u = recycledU;
        }

        const u = seg.u; // 0 top, 1 bottom
        // ease interpolation to bias more distance near viewer
        const eased = u * (2 - u);
        const baseX = (1 - eased) * vpX + eased * (w / 2);
        const y = (1 - eased) * vpY + eased * bottomY();

        // wobble & lateral dispersion -> increase effect nearer bottom (u^1.35)
        seg.wobblePhase += seg.wobbleSpeed * dt;
        const wobble = Math.sin(seg.wobblePhase + cameraBob * 5.5) * 0.55 + Math.sin(seg.wobblePhase * 0.6) * 0.35;
        const lateralFactor = Math.pow(u, 1.35);
        const lateralOffset = (seg.offsetX * lateralFactor + wobble * 0.02 * lateralFactor) * (w * 0.18);
        const x = baseX + lateralOffset;

        // perspective scaling with slight bias to grow quicker near bottom
        const scale = 0.22 + 0.85 * Math.pow(u, 1.08);
        const segW = Math.max(3, 8 * scale); // keep narrow
        const segH = Math.max(8, 42 * scale * seg.lenFactor); // variable length

        // Fade out towards top; slight brightness modulation
        const alpha = Math.min(1, Math.max(0, (u - 0.015) / 0.985));
        const brightness = 0.90 + Math.sin(seg.wobblePhase * 1.4 + i) * 0.07;
        const light = `rgba(240,230,200,${(alpha * brightness).toFixed(3)})`;
        const dark = `rgba(60,55,50,${(alpha * 0.92).toFixed(3)})`;
        ctx.fillStyle = (i % 2 === 0) ? light : dark;
        ctx.fillRect(
          Math.round(x - segW / 2),
          Math.round(y - segH / 2),
          Math.round(segW),
          Math.round(segH)
        );
      }

      // subtle global vignette/grunge
      ctx.fillStyle = "rgba(0,0,0,0.02)";
      ctx.fillRect(0, 0, w, h);

      requestAnimationFrame(animate);
    }

    requestAnimationFrame((ts) => {
      last = ts;
      animate(ts);
    });

    // Expose to window for quick debugging
    win.roadAnimation = {
      stop() { running = false; },
      start() { if (!running) { running = true; last = performance.now(); requestAnimationFrame(animate); } },
      reset() { initSegments(); },
      info() { return { w, h, heroRect, segmentsCount: segments.length, sample: segments.slice(0,3) }; },
    };
  });
</script>

<style>
  .road-canvas {
    position: fixed;
    inset: 0; /* top:0; right:0; bottom:0; left:0; */
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0; /* sits underneath page content which should use higher z-index */
    mix-blend-mode: normal;
  }
  @media (prefers-reduced-motion: reduce) {
    .road-canvas {
      display: none;
    }
  }
</style>
