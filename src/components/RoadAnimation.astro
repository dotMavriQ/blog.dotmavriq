---
// RoadAnimation.astro
// Minimal, reliable single-canvas road animation:
// - Two edge lines (no fill) aimed at the hero "hips"
// - Moving checkered center line to suggest forward motion
// - Uses devicePixelRatio scaling to be sharp
// - ResizeObserver keeps geometry in sync
// - Canvas is under page content (low z-index) and pointer-events disabled
---

<canvas id="road-canvas" class="road-canvas" aria-hidden="true"></canvas>

<script>
  // @ts-nocheck
  // Provide ambient declaration for tooling (ignored at runtime)
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  /**
   * @typedef {Object} RoadAnimationAPI
   * @property {() => void} stop
   * @property {() => void} start
   * @property {() => { w:number, h:number, heroRect:DOMRect, segmentsCount:number }} info
   */
  document.addEventListener("DOMContentLoaded", () => {
    /** @type {HTMLCanvasElement | null} */
    const canvas = document.getElementById("road-canvas");
    if (!canvas) return;
    /** @type {CanvasRenderingContext2D | null} */
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const win = /** @type {any} */ (window);

    // Respect prefers-reduced-motion
    if (
      window.matchMedia &&
      window.matchMedia("(prefers-reduced-motion: reduce)").matches
    ) {
      canvas.style.display = "none";
      return;
    }

    canvas.style.pointerEvents = "none";

    let dpr = Math.max(1, window.devicePixelRatio || 1);
    let w = 0,
      h = 0;

    function setSize() {
      dpr = Math.max(1, window.devicePixelRatio || 1);
      w = Math.max(1, window.innerWidth);
      h = Math.max(1, window.innerHeight);
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    setSize();
    window.addEventListener("resize", setSize);

    // Hero element; fallback if not present
    function getHeroRect() {
      const el = document.querySelector(".hero-image");
      if (!el) {
        const size = Math.min(180, Math.max(120, w * 0.18));
        return {
          left: (w - size) / 2,
          top: h * 0.35,
          width: size,
          height: size,
          bottom: h * 0.35 + size,
        };
      }
      const rect = el.getBoundingClientRect();
      // Virtual upward shift: if CSS --hero-offset (margin pushing GIF down) exists, subtract it so
      // road apex calculation still uses the original visual attachment point while allowing the
      // GIF to be displayed lower without shortening the apparent road above.
      let offset = 0;
      try {
        const cs = getComputedStyle(el);
        const v = cs.getPropertyValue("--hero-offset");
        if (v) offset = parseFloat(v) || 0;
      } catch {}
      if (offset) {
        return {
          left: rect.left,
          top: rect.top - offset,
          width: rect.width,
          height: rect.height,
          bottom: rect.bottom - offset,
        };
      }
      return rect;
    }

    let heroRect = getHeroRect();

    // Keep heroRect current
    if (window.ResizeObserver) {
      const heroEl = document.querySelector(".hero-image");
      if (heroEl) {
        new ResizeObserver(() => {
          heroRect = heroEl.getBoundingClientRect();
        }).observe(heroEl);
      }
    }

    // Road geometry helpers
    const leftX = () => Math.round(w * 0.14);
    const rightX = () => Math.round(w * 0.86);
    // Extend road below the visible viewport so dashes emerge organically instead of at the footer edge
    let bottomExtra = 0; // will be set in setSizeDerived()
    const roadBottomY = () => Math.round(h + bottomExtra); // logical bottom for perspective math

    function setSizeDerived() {
      // extra extension capped for very tall screens
      bottomExtra = Math.min(180, Math.max(80, h * 0.18));
    }
    setSizeDerived();

    // Center-line: single straight dashed sequence, uniform color & subtle taper.
    /** @type {number[]} */
    let segments = [];
    const gapU = 0.11; // dash spacing (parameter space)
    const EXTRA = 4; // extra for seamless wrap
    function initSegments() {
      segments = [];
      const count = Math.ceil(1 / gapU) + EXTRA;
      for (let i = 0; i < count; i++) segments.push((i * gapU) % 1);
    }
    initSegments();

    // Animation state
    let last = performance.now();
    let running = true;

    function animate(now) {
      if (!running) return;
      const dt = Math.min(40, now - last) / 1000; // seconds
      last = now;

      // update sizes in case of change
      heroRect = getHeroRect();

      // vanishing point ("hips") - slightly above bottom of hero
      const vpX = (heroRect.left || 0) + (heroRect.width || 0) / 2;
      const vpY = (heroRect.bottom || h * 0.55) - (heroRect.height || 0) * 0.32;
      // Recompute bottomExtra on resize-driven frames (cheap)
      setSizeDerived();

      // clear
      ctx.clearRect(0, 0, w, h);

      // draw road edges (stroked lines, no fill) with subtle top fade into background
      const edgeWidth = Math.max(2, (heroRect.width || 120) * 0.02);
      ctx.lineWidth = edgeWidth;
      ctx.lineCap = "round";
      const edgeColor = "rgba(220,200,150,0.97)";
      // Fade only a short distance ("not too much") from the vanishing point downward
      const fadeHeight = Math.min(140, Math.max(70, h * 0.14));
      // Gradient goes from background (#282828) at vpY to edgeColor after fadeHeight
      const g = ctx.createLinearGradient(0, vpY, 0, vpY + fadeHeight);
      g.addColorStop(0, "#282828");
      g.addColorStop(0.35, "rgba(40,40,40,0.4)"); // gentle transition ramp
      g.addColorStop(0.7, edgeColor);
      g.addColorStop(1, edgeColor);
      ctx.strokeStyle = g;

      ctx.beginPath();
      ctx.moveTo(leftX(), h); // draw edge to visible bottom only
      ctx.lineTo(vpX - Math.max(12, (heroRect.width || 120) * 0.12), vpY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(rightX(), h); // visible bottom
      ctx.lineTo(vpX + Math.max(12, (heroRect.width || 120) * 0.12), vpY);
      ctx.stroke();

      // (Removed center guide line to avoid visual overlap with hero & icons)

      // Animate center dashes (natural speed tied to perspective length, independent of hero offset)
      const perspectiveLength = Math.max(1, roadBottomY() - vpY);
      // Slower, more natural base speed tied to perspective length
      const speedPx = (() => {
        const raw = perspectiveLength * 0.14; // slightly slower factor
        return Math.min(240, Math.max(85, raw));
      })();
      const speedU = (speedPx * dt) / perspectiveLength; // parameter space speed

      // Update positions & wrap
      for (let i = 0; i < segments.length; i++) {
        segments[i] -= speedU;
        if (segments[i] < 0) segments[i] += 1;
      }
      // Build dash geometry list then sort top->bottom (y ascending) so we can enforce spacing
      const dashData = [];
      for (let i = 0; i < segments.length; i++) {
        const u = segments[i];
        const eased = u * (2 - u); // perspective easing
        const centerX = (1 - eased) * vpX + eased * (w / 2);
        // Map to extended bottom then shift upward so emergence happens off-screen
        const logicalY = (1 - eased) * vpY + eased * roadBottomY();
        // Spawn well BELOW viewport then glide in (immersive emergence from "under footer")
        const spawnBelow = 240; // px below bottom edge
        const centerY = logicalY - bottomExtra + spawnBelow;
        // Smooth cubic easing for size (less abrupt near midpoint)
        const sizeEase = eased * eased * (3 - 2 * eased); // smoothstep 0..1
        // Smoother, more gradual growth (slightly smaller top, a bit taller bottom)
        const scale = 0.12 + 1.05 * sizeEase; // 0.12 top -> ~1.17 bottom
        // Width/height derived with gentle non-linear easing to reduce popping
        // Make initial (near top) dashes a bit larger for readability while keeping bottom similar.
        // Raise base sizes and slightly reduce growth amplitude.
        const segW = 4 + 3.8 * Math.pow(sizeEase, 0.7); // 4 -> ~7.8px
        const segH = 18 + 46 * sizeEase; // 18 -> 64px
        const taperShift = (1 - u) * (vpX - w / 2) * 0.015;
        // Alpha ramp (earlier presence, slower fade): extend pre-fade domain for small top dashes
        const rawA = Math.min(1, Math.max(0, (u - 0.006) / 0.955));
        const smooth = rawA * rawA * (3 - 2 * rawA);
        const alpha = 0.35 * rawA + 0.65 * smooth; // lean a bit more on smooth curve
        dashData.push({
          u,
          eased,
          x: centerX + taperShift,
          y: centerY,
          w: segW,
          h: segH,
          alpha,
        });
      }
      dashData.sort((a, b) => a.y - b.y); // top (vanishing point) first

      let prevBottom = -Infinity;
      // Safe zone: suppress dash rendering near hero & link cluster so center line always reads as *under* UI
      // Allow dashes to come closer to the hero feet: reduce buffer from 25% height to ~5%.
      const safeZoneLimit =
        (heroRect.bottom || h * 0.55) + (heroRect.height || 120) * 0.05; // tighter buffer so dashes meet feet visually
      for (const d of dashData) {
        // Skip any dash whose lower edge intrudes into safe zone
        if (d.y + d.h / 2 < safeZoneLimit) {
          prevBottom = Math.max(prevBottom, d.y + d.h / 2);
          continue;
        }
        // dynamic minimum gap in pixels: smaller near top, larger near bottom
        const gapEase = d.eased * d.eased * (3 - 2 * d.eased);
        // Increase growth a bit for natural perspective spacing (tighter near top, wider near bottom)
        const gap = 4 + 22 * gapEase;
        const halfH = d.h / 2;
        const top = d.y - halfH;
        if (top < prevBottom + gap) continue; // skip to avoid collision / overlap
        const segX = Math.round(d.x - d.w / 2);
        const segY = Math.round(d.y - halfH);
        // Fade-in for below-viewport spawn
        let a = d.alpha;
        if (d.y > h) {
          const fadeSpan = 260; // fade span depth
          const distBelow = Math.min(fadeSpan, d.y - h);
          const t = 1 - distBelow / fadeSpan; // 0 far below -> 1 at viewport edge
          const eased = t * t * (3 - 2 * t); // smoothstep for softness
          a *= eased;
        }
        const brightnessBias = 0.18 + 0.82 * a;
        ctx.fillStyle = `rgba(235,219,178,${(0.9 * brightnessBias).toFixed(3)})`;
        // Only draw if meaningful opacity (saves fill calls)
        if (brightnessBias > 0.02) {
          ctx.fillRect(segX, segY, Math.round(d.w), Math.round(d.h));
        }
        prevBottom = segY + d.h;
      }

      // subtle global vignette/grunge
      ctx.fillStyle = "rgba(0,0,0,0.02)";
      ctx.fillRect(0, 0, w, h);

      requestAnimationFrame(animate);
    }

    requestAnimationFrame((ts) => {
      last = ts;
      animate(ts);
    });

    // Expose to window for quick debugging
    win.roadAnimation = {
      stop() {
        running = false;
      },
      start() {
        if (!running) {
          running = true;
          last = performance.now();
          requestAnimationFrame(animate);
        }
      },
      reset() {
        initSegments();
      },
      info() {
        return { w, h, heroRect, segmentsCount: segments.length };
      },
    };
  });
</script>

<style>
  .road-canvas {
    position: fixed;
    inset: 0; /* top:0; right:0; bottom:0; left:0; */
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0; /* ensure it's below page content (content containers use higher z-index) */
    mix-blend-mode: normal;
  }
  @media (prefers-reduced-motion: reduce) {
    .road-canvas {
      display: none;
    }
  }
</style>
