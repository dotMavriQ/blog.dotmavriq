---
// RoadAnimation.astro
// Minimal, reliable single-canvas road animation:
// - Two edge lines (no fill) aimed at the hero "hips"
// - Moving checkered center line to suggest forward motion
// - Uses devicePixelRatio scaling to be sharp
// - ResizeObserver keeps geometry in sync
// - Canvas is under page content (low z-index) and pointer-events disabled
---

<canvas id="road-canvas" class="road-canvas" aria-hidden="true"></canvas>

<script>
  // @ts-nocheck
  // Provide ambient declaration for tooling (ignored at runtime)
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  /**
   * @typedef {Object} RoadAnimationAPI
   * @property {() => void} stop
   * @property {() => void} start
   * @property {() => { w:number, h:number, heroRect:DOMRect, segmentsCount:number }} info
   */
  document.addEventListener("DOMContentLoaded", () => {
    /** @type {HTMLCanvasElement | null} */
    const canvas = document.getElementById("road-canvas");
    if (!canvas) return;
    /** @type {CanvasRenderingContext2D | null} */
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const win = /** @type {any} */ (window);

    // Respect prefers-reduced-motion
    if (
      window.matchMedia &&
      window.matchMedia("(prefers-reduced-motion: reduce)").matches
    ) {
      canvas.style.display = "none";
      return;
    }

    canvas.style.pointerEvents = "none";

    let dpr = Math.max(1, window.devicePixelRatio || 1);
    let w = 0,
      h = 0;

    function setSize() {
      dpr = Math.max(1, window.devicePixelRatio || 1);
      w = Math.max(1, window.innerWidth);
      h = Math.max(1, window.innerHeight);
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    setSize();
    window.addEventListener("resize", setSize);

    // Hero element; fallback if not present
    function getHeroRect() {
      const el = document.querySelector(".hero-image");
      if (!el) {
        const size = Math.min(180, Math.max(120, w * 0.18));
        return {
          left: (w - size) / 2,
          top: h * 0.35,
          width: size,
          height: size,
          bottom: h * 0.35 + size,
        };
      }
      return el.getBoundingClientRect();
    }

    let heroRect = getHeroRect();

    // Keep heroRect current
    if (window.ResizeObserver) {
      const heroEl = document.querySelector(".hero-image");
      if (heroEl) {
        new ResizeObserver(() => {
          heroRect = heroEl.getBoundingClientRect();
        }).observe(heroEl);
      }
    }

    // Road geometry helpers
    const leftX = () => Math.round(w * 0.14);
    const rightX = () => Math.round(w * 0.86);
    // Extend road below the visible viewport so dashes emerge organically instead of at the footer edge
    let bottomExtra = 0; // will be set in setSizeDerived()
    const roadBottomY = () => Math.round(h + bottomExtra); // logical bottom for perspective math

    function setSizeDerived() {
      // extra extension capped for very tall screens
      bottomExtra = Math.min(180, Math.max(80, h * 0.18));
    }
    setSizeDerived();

    // Center-line: single straight dashed sequence, uniform color & subtle taper.
    /** @type {number[]} */
    let segments = [];
    const gapU = 0.11; // dash spacing (parameter space)
    const EXTRA = 4; // extra for seamless wrap
    function initSegments() {
      segments = [];
      const count = Math.ceil(1 / gapU) + EXTRA;
      for (let i = 0; i < count; i++) segments.push((i * gapU) % 1);
    }
    initSegments();

    // Animation state
    let last = performance.now();
    let running = true;

    function animate(now) {
      if (!running) return;
      const dt = Math.min(40, now - last) / 1000; // seconds
      last = now;

      // update sizes in case of change
      heroRect = getHeroRect();

      // vanishing point ("hips") - slightly above bottom of hero
      const vpX = (heroRect.left || 0) + (heroRect.width || 0) / 2;
      const vpY = (heroRect.bottom || h * 0.55) - (heroRect.height || 0) * 0.32;
      // Recompute bottomExtra on resize-driven frames (cheap)
      setSizeDerived();

      // clear
      ctx.clearRect(0, 0, w, h);

      // draw road edges (stroked lines, no fill)
      const edgeWidth = Math.max(2, (heroRect.width || 120) * 0.02);
      ctx.lineWidth = edgeWidth;
      ctx.lineCap = "round";
      ctx.strokeStyle = "rgba(220,200,150,0.98)";

      ctx.beginPath();
      ctx.moveTo(leftX(), h); // draw edge to visible bottom only
      ctx.lineTo(vpX - Math.max(12, (heroRect.width || 120) * 0.12), vpY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(rightX(), h); // visible bottom
      ctx.lineTo(vpX + Math.max(12, (heroRect.width || 120) * 0.12), vpY);
      ctx.stroke();

      // (Removed center guide line to avoid visual overlap with hero & icons)

      // Animate center dashes (uniform speed, no lateral drift)
      const speedPx = Math.max(14, (heroRect.width || 120) * 0.4);
      // convert to parameter-space speed (approx): when u moves from 0 to 1, y goes from vpY to bottom
      const approxLength = roadBottomY() - vpY;
      const speedU = (speedPx * dt) / Math.max(approxLength, 1);

      // Update positions & wrap
      for (let i = 0; i < segments.length; i++) {
        segments[i] -= speedU;
        if (segments[i] < 0) segments[i] += 1;
      }
      // Build dash geometry list then sort top->bottom (y ascending) so we can enforce spacing
      const dashData = [];
      for (let i = 0; i < segments.length; i++) {
        const u = segments[i];
        const eased = u * (2 - u); // perspective easing
        const centerX = (1 - eased) * vpX + eased * (w / 2);
        // Map to extended bottom then shift upward so emergence happens off-screen
        const logicalY = (1 - eased) * vpY + eased * roadBottomY();
        const centerY = logicalY - bottomExtra; // shift into visible space later, causing spawn below
        // Smooth cubic easing for size (less abrupt near midpoint)
        const sizeEase = eased * eased * (3 - 2 * eased); // smoothstep
        // Start bottom bigger relative to previous (increase max height + width)
        const scale = 0.18 + 0.9 * sizeEase; // 0.18 top -> ~1.08 bottom
        const segW = Math.max(3, 6 * scale); // keep narrow
        const segH = Math.max(10, 48 * scale); // taller for stronger approach effect
        const taperShift = (1 - u) * (vpX - w / 2) * 0.015;
        // Smooth alpha ramp (quadratic) to reduce choppiness at top emergence
        const rawA = Math.min(1, Math.max(0, (u - 0.02) / 0.98));
        const alpha = rawA * rawA * (3 - 2 * rawA); // smoothstep
        dashData.push({
          u,
          eased,
          x: centerX + taperShift,
          y: centerY,
          w: segW,
          h: segH,
          alpha,
        });
      }
      dashData.sort((a, b) => a.y - b.y); // top (vanishing point) first

      let prevBottom = -Infinity;
      // Safe zone: suppress dash rendering near hero & link cluster so center line always reads as *under* UI
      const safeZoneLimit =
        (heroRect.bottom || h * 0.55) + (heroRect.height || 120) * 0.25; // small buffered region
      for (const d of dashData) {
        // Skip any dash whose lower edge intrudes into safe zone
        if (d.y + d.h / 2 < safeZoneLimit) {
          prevBottom = Math.max(prevBottom, d.y + d.h / 2);
          continue;
        }
        // dynamic minimum gap in pixels: smaller near top, larger near bottom
        const gapEase = d.eased * d.eased * (3 - 2 * d.eased);
        const gap = 5 + 16 * gapEase; // smoother growth of spacing
        const halfH = d.h / 2;
        const top = d.y - halfH;
        if (top < prevBottom + gap) continue; // skip to avoid collision / overlap
        const segX = Math.round(d.x - d.w / 2);
        const segY = Math.round(d.y - halfH);
        ctx.fillStyle = `rgba(235,219,178,${(0.9 * d.alpha).toFixed(3)})`;
        ctx.fillRect(segX, segY, Math.round(d.w), Math.round(d.h));
        prevBottom = segY + d.h;
      }

      // subtle global vignette/grunge
      ctx.fillStyle = "rgba(0,0,0,0.02)";
      ctx.fillRect(0, 0, w, h);

      requestAnimationFrame(animate);
    }

    requestAnimationFrame((ts) => {
      last = ts;
      animate(ts);
    });

    // Expose to window for quick debugging
    win.roadAnimation = {
      stop() {
        running = false;
      },
      start() {
        if (!running) {
          running = true;
          last = performance.now();
          requestAnimationFrame(animate);
        }
      },
      reset() {
        initSegments();
      },
      info() {
        return { w, h, heroRect, segmentsCount: segments.length };
      },
    };
  });
</script>

<style>
  .road-canvas {
    position: fixed;
    inset: 0; /* top:0; right:0; bottom:0; left:0; */
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1; /* above background, still below content (content uses z-20) */
    mix-blend-mode: normal;
  }
  @media (prefers-reduced-motion: reduce) {
    .road-canvas {
      display: none;
    }
  }
</style>
