---
// Canvas-based road animation component for the homepage
---

<canvas id="road-canvas" class="road-canvas"></canvas>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('road-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Get hero image for alignment
    const heroImage = document.querySelector('.hero-image');
    if (!heroImage) return;

    // Resize canvas to fill the viewport
    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Gruvbox dark colors
    const colors = {
      bg0: '#282828', // Dark background
      bg1: '#3c3836', // Slightly lighter background
      bg2: '#504945', // Lighter background
      bg3: '#665c54', // Lightest background
      fg: '#ebdbb2',  // Normal foreground
      fg2: '#d5c4a1'  // Darker foreground
    };

    // Animation settings
    let roadSpeed = -2; // Base speed that will be adjusted (negative for opposite direction)

    // Adjust speed based on character size
    function updateRoadSpeed() {
      const heroImg = document.querySelector('.hero-image');
      if (heroImg) {
        const rect = heroImg.getBoundingClientRect();
        // Scale speed with character height - smaller character = slower speed
        // Negative to make stripes come toward the viewer
        roadSpeed = -Math.max(1.5, Math.min(4, rect.height / 60));
      }
    }
    updateRoadSpeed();

    // Calculate perspective points and road segments
    let segments = [];
    let segmentSpacing = 150; // Default spacing that will be adjusted

    // Initialize road segments with spacing based on character size
    function initSegments() {
      const heroImg = document.querySelector('.hero-image');
      if (heroImg) {
        // Adjust segment spacing based on character size
        const rect = heroImg.getBoundingClientRect();
        // Increase spacing between segments to make them look like proper road stripes
        segmentSpacing = Math.max(100, rect.height * 1.2); // Larger spacing between stripes
      }

      segments = [];
      for (let pos = 0; pos < window.innerHeight * 2; pos += segmentSpacing) {
        segments.push(pos % window.innerHeight); // Make sure they wrap correctly
      }
    }

    initSegments();

    // Main animation function
    function animate() {
      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Get character position from the GIF image
      const rect = heroImage.getBoundingClientRect();
      const characterX = window.innerWidth / 2; // Center horizontally
      const characterY = rect.bottom - 5; // Position just below character's feet

      // Calculate vanishing point based on character position
      // Place vanishing point above the character at a proportional distance that fits the viewport
      const vanishingPointY = Math.max(window.innerHeight * 0.1, characterY - Math.min(rect.height * 2, window.innerHeight * 0.3));

      // Calculate road width proportionally to character size
      const charWidth = rect.width;
      const roadWidthAtVP = Math.max(20, charWidth * 0.3); // Narrow at vanishing point

      // Make road wider at bottom proportional to character size but constrained
      const roadWidthAtBottom = Math.min(window.innerWidth * 0.4, charWidth * 4);

      // Calculate road dimensions
      const roadHeight = characterY - vanishingPointY;
      const roadWidthAtTop = roadWidthAtVP;
      const roadWidthAtScreenBottom = roadWidthAtBottom * 1.2; // Slightly wider at very bottom

      // Draw road background - extend to bottom of screen
      const bottomY = window.innerHeight;

      // Create gradient for a more dimensional road
      const roadGradient = ctx.createLinearGradient(0, vanishingPointY, 0, bottomY);
      roadGradient.addColorStop(0, colors.bg0); // Darker at vanishing point
      roadGradient.addColorStop(1, colors.bg1); // Slightly lighter at bottom

      ctx.fillStyle = roadGradient;
      ctx.beginPath();
      ctx.moveTo(characterX - roadWidthAtTop / 2, vanishingPointY); // Top left
      ctx.lineTo(characterX + roadWidthAtTop / 2, vanishingPointY); // Top right
      ctx.lineTo(characterX + roadWidthAtScreenBottom / 2, bottomY); // Bottom right
      ctx.lineTo(characterX - roadWidthAtScreenBottom / 2, bottomY); // Bottom left
      ctx.closePath();
      ctx.fill();

      // Keep clean appearance without texture

      // Draw road edges - extend to bottom of screen
      // Create gradient for edges
      const edgeGradient = ctx.createLinearGradient(0, vanishingPointY, 0, bottomY);
      edgeGradient.addColorStop(0, colors.bg3); // More visible near top
      edgeGradient.addColorStop(1, colors.bg2); // Less visible at bottom

      ctx.strokeStyle = edgeGradient;
      ctx.lineWidth = 1.5; // Slightly thinner line

      // Left edge
      ctx.beginPath();
      ctx.moveTo(characterX - roadWidthAtTop / 2, vanishingPointY);
      ctx.lineTo(characterX - roadWidthAtScreenBottom / 2, bottomY);
      ctx.stroke();

      // Right edge
      ctx.beginPath();
      ctx.moveTo(characterX + roadWidthAtTop / 2, vanishingPointY);
      ctx.lineTo(characterX + roadWidthAtScreenBottom / 2, bottomY);
      ctx.stroke();

      // Add subtle grunge overlay
      ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Add a faint center divider line
      ctx.strokeStyle = `rgba(${parseInt(colors.fg2.slice(1, 3), 16)}, ${parseInt(colors.fg2.slice(3, 5), 16)}, ${parseInt(colors.fg2.slice(5, 7), 16)}, 0.15)`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(characterX, vanishingPointY);
      ctx.lineTo(characterX, characterY);
      ctx.stroke();

      // Draw the moving checkered mid-line segments
      for (let i = 0; i < segments.length; i++) {
        // Update segment position
        segments[i] += roadSpeed;
        if (segments[i] > canvas.height) {
          segments[i] = 0;
        }

        // Calculate interpolation factor (t=0 at vanishing point, t=1 at bottom)
        const t = segments[i] / canvas.height;

        // Calculate position using interpolation
        const yPos = (1 - t) * vanishingPointY + t * bottomY;

        // Only draw segments that are between the vanishing point and the character's feet
        if (yPos >= vanishingPointY && yPos <= characterY) {
          // Calculate width at this y-position (interpolate from top to bottom)
          const segmentProgress = (yPos - vanishingPointY) / (characterY - vanishingPointY);

          // Adjust segment size for perspective - proportional to road width
          const roadWidthAtThisPoint = roadWidthAtTop + segmentProgress * (roadWidthAtBottom - roadWidthAtTop);

          // Much narrower segments that look like actual road stripes
          const segmentWidth = Math.max(4, roadWidthAtThisPoint * 0.06); // Make stripes narrower
          const segmentHeight = Math.max(2, roadWidthAtThisPoint * 0.03); // Much shorter segments

          // Use only the lighter color for better visibility
          ctx.fillStyle = colors.fg2;

          // Draw segment
          ctx.fillRect(
            characterX - segmentWidth / 2, // Center the rectangle
            yPos - segmentHeight / 2, // Center vertically
            segmentWidth,
            segmentHeight
          );
        }
      }

      requestAnimationFrame(animate);
    }

    // Start animation
    animate(); // Initial call to start the animation loop

    // Handle resize and scroll
    window.addEventListener('resize', () => {
      resizeCanvas();
      updateRoadSpeed(); // Recalculate speed based on new character size
      initSegments(); // Reset segments with new spacing
    });

    window.addEventListener('scroll', () => {
      // The animation function will use the updated position
    });
  });
</script>

<style>
  .road-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1; /* Keep low to ensure other elements appear above */
    touch-action: none; /* Prevent touch scrolling */
    -webkit-user-select: none; /* Prevent selection */
    user-select: none;
  }

  @media (prefers-reduced-motion: reduce) {
    .road-canvas {
      display: none;
    }
  }
</style>
