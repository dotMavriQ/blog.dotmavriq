---
// Canvas-based road animation component for the homepage
---

<canvas id="road-canvas" class="road-canvas"></canvas>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('road-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Get hero image for alignment (solid snake gif)
    const heroImage = document.querySelector('.hero-image');
    if (!heroImage) return;

    // Get footer for detecting where road should end
    const footer = document.querySelector('footer');
    if (!footer) return;

    // Resize canvas to fill the viewport
    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Cache hero dimensions to avoid per-frame jitter caused by small CSS animations
    const getHeroRect = () => heroImage.getBoundingClientRect();
    let heroRect = getHeroRect();
    let cachedCharX = heroRect.left + heroRect.width / 2;
    let cachedCharY = heroRect.bottom - 5;
    let cachedCharWidth = heroRect.width;
    let cachedVanishingPointY = Math.max(window.innerHeight * 0.05, cachedCharY - Math.min(cachedCharWidth * 3, window.innerHeight * 0.4));

    function updateHeroCache() {
      heroRect = getHeroRect();
      cachedCharX = heroRect.left + heroRect.width / 2;
      cachedCharY = heroRect.bottom - 5;
      cachedCharWidth = heroRect.width;
      cachedVanishingPointY = Math.max(window.innerHeight * 0.05, cachedCharY - Math.min(cachedCharWidth * 3, window.innerHeight * 0.4));
    }

    // Update caches initially and on resize only
    updateHeroCache();
    window.addEventListener('resize', () => {
      resizeCanvas();
      updateHeroCache();
      updateRoadSpeed(); // Recalculate speed based on new character size
      initSegments(); // Reset segments with new spacing
    });

    // Gruvbox dark colors
    const colors = {
      bg0: '#282828', // Dark background
      bg1: '#3c3836', // Slightly lighter background
      bg2: '#504945', // Lighter background
      bg3: '#665c54', // Lightest background
      bg4: '#7c6f64', // Lightest greys
      fg: '#ebdbb2',  // Normal foreground
      fg2: '#d5c4a1', // Darker foreground
      fg3: '#bdae93', // Even darker foreground
      yellow: '#ebdbb2', // Accent color for road markings (changed from #fabd2f to #ebdbb2)
      green: '#b8bb26'  // Alternative accent color
    };

    // Animation settings
    let roadSpeed = -5; // Negative means stripes moving toward viewer - increased speed

    // Adjust speed based on character size and screen height
    function updateRoadSpeed() {
      const heroImg = document.querySelector('.hero-image');
      if (heroImg) {
        const rect = heroImg.getBoundingClientRect();
        // Set a faster speed for more dramatic motion
        roadSpeed = -Math.max(4, Math.min(6, rect.height / 30));
      }
    }
    updateRoadSpeed();

    // Track if animation should be active
    let animationActive = true;

    // Check if we're at the footer and should stop animation
    function checkFooterVisibility() {
      if (!footer) return;
      const footerRect = footer.getBoundingClientRect();
      // If footer is in view, gradually slow down the animation
      if (footerRect.top < window.innerHeight) {
        const visibleRatio = (window.innerHeight - footerRect.top) / footerRect.height;
        animationActive = visibleRatio < 0.8; // Stop completely when footer is 80% visible
        // Gradually slow down as footer becomes visible
        if (animationActive && visibleRatio > 0) {
          roadSpeed = roadSpeed * (1 - visibleRatio);
        }
      } else {
        animationActive = true;
      }
    }

    // Calculate perspective points and road segments
    let segments = [];
    let segmentSpacing = 120; // Default spacing that will be adjusted

    // Add side elements for more depth perception
    let sideElements = [];
    const numSideElements = 12; // Number of elements on each side

    // Create side elements for enhanced depth perception
    function initSideElements() {
      sideElements = [];
      // Create different side elements with varied shapes/sizes for both sides
      for (let i = 0; i < numSideElements; i++) {
        // Left side elements
        sideElements.push({
          side: 'left',
          y: Math.random() * window.innerHeight,
          size: 4 + Math.random() * 8,
          color: i % 3 === 0 ? colors.green : colors.fg3,
          shape: i % 4 // 0: circle, 1: square, 2: triangle, 3: dash
        });

        // Right side elements
        sideElements.push({
          side: 'right',
          y: Math.random() * window.innerHeight,
          size: 4 + Math.random() * 8,
          color: i % 3 === 0 ? colors.green : colors.fg3,
          shape: i % 4
        });
      }
    }

    // Initialize road segments with spacing based on character size
    function initSegments() {
      const heroImg = document.querySelector('.hero-image');
      if (heroImg) {
        // Adjust segment spacing based on character size
        const rect = heroImg.getBoundingClientRect();
        // Create more frequent road markings for better animation
        segmentSpacing = Math.max(40, rect.height * 0.5); // Shorter spacing for more frequent stripes
      }

      segments = [];
      // Create evenly spaced segments from vanishing point to bottom
      const footer = document.querySelector('footer');
      const bottomY = footer ? footer.getBoundingClientRect().top : window.innerHeight;
      // Use cachedVanishingPointY so segments line up with the cached geometry
      const vanishingPointY = (typeof cachedVanishingPointY !== 'undefined') ? cachedVanishingPointY : window.innerHeight * 0.05;

      // Calculate number of segments needed to fill the road
      const roadHeight = bottomY - vanishingPointY;
      const numSegments = Math.ceil(roadHeight / segmentSpacing) + 2; // Add extra segments for smooth scrolling

      // Create segments with precise spacing
      for (let i = 0; i < numSegments; i++) {
        segments.push(vanishingPointY + (i * segmentSpacing));
      }

      // Initialize side elements
      initSideElements();
    }

    initSegments();

    // Main animation function
    function animate() {
      // Check if we're at the footer and should stop/slow animation
      checkFooterVisibility();

      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Use cached hero geometry (prevents micro-jitter because the GIF has a subtle CSS animation)
      const characterX = cachedCharX;
      const characterY = cachedCharY;
      const vanishingPointY = cachedVanishingPointY;

      // Calculate road width proportionally to cached character size
      const charWidth = cachedCharWidth;

      // Make the road narrower at vanishing point for stronger perspective
      const roadWidthAtVP = Math.max(15, charWidth * 0.2); 

      // Make road wider at bottom for stronger perspective effect
      const roadWidthAtBottom = Math.min(window.innerWidth * 0.5, charWidth * 5);

      // Calculate road dimensions
      const roadHeight = characterY - vanishingPointY;
      const roadWidthAtTop = roadWidthAtVP;
      // Wider road at bottom of screen creates more dramatic perspective
      const roadWidthAtScreenBottom = roadWidthAtBottom * 1.4; 

      // Get the footer position to determine where road should visually end
      const footerRect = footer.getBoundingClientRect();
      // Determine drawing bottom (do not exceed viewport)
      const bottomY = Math.min(window.innerHeight, footerRect.top);

      // Intentionally do NOT draw a filled road background so the page content
      // remains visible. We'll only draw road edges and center/stripe markings.
 
      // Draw road edges with solid color for cleaner look
      ctx.strokeStyle = colors.yellow; // Use solid yellow for edges
      ctx.lineWidth = 2.5; // Thicker line for better visibility
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';

      // Draw left edge (use rounded integer coords to avoid subpixel jitter)
      const leftTopX = Math.round(characterX - roadWidthAtTop / 2);
      const leftBottomX = Math.round(characterX - roadWidthAtScreenBottom / 2);
      const rightTopX = Math.round(characterX + roadWidthAtTop / 2);
      const rightBottomX = Math.round(characterX + roadWidthAtScreenBottom / 2);

      ctx.beginPath();
      ctx.moveTo(leftTopX, Math.round(vanishingPointY));
      ctx.lineTo(leftBottomX, Math.round(bottomY));
      ctx.stroke();

      // Right edge
      ctx.beginPath();
      ctx.moveTo(rightTopX, Math.round(vanishingPointY));
      ctx.lineTo(rightBottomX, Math.round(bottomY));
      ctx.stroke();

      // Note: the moving center stripes are drawn using the 'segments' array below.
      // This avoids a separate dashed algorithm and keeps movement consistent.

      // Draw the moving road stripes/segments
      if (animationActive) {
        const range = bottomY - vanishingPointY || 1;
        for (let i = 0; i < segments.length; i++) {
          // Modular wrapping to avoid jumps
          segments[i] = ((segments[i] - vanishingPointY + roadSpeed) % range + range) % range + vanishingPointY;

          const yPos = segments[i];

          // Only draw segments that are between the vanishing point and bottom
          if (yPos >= vanishingPointY && yPos <= bottomY) {
            const segmentProgress = (yPos - vanishingPointY) / (bottomY - vanishingPointY);
            const roadWidthAtThisPoint = roadWidthAtTop + segmentProgress * (roadWidthAtBottom - roadWidthAtTop);

            const segmentWidth = Math.max(8, roadWidthAtThisPoint * 0.2);
            const segmentHeight = Math.max(4, roadWidthAtThisPoint * 0.03);

            ctx.fillStyle = colors.yellow;

            // Left stripe
            ctx.fillRect(
              Math.round(characterX - (roadWidthAtThisPoint * 0.25) - segmentWidth/2),
              Math.round(yPos - segmentHeight / 2),
              Math.round(segmentWidth),
              Math.round(segmentHeight)
            );

            // Right stripe
            ctx.fillRect(
              Math.round(characterX + (roadWidthAtThisPoint * 0.25) - segmentWidth/2),
              Math.round(yPos - segmentHeight / 2),
              Math.round(segmentWidth),
              Math.round(segmentHeight)
            );

            // Center dashed stripe (small vertical dash centered on characterX)
            const centerWidth = Math.max(3, segmentWidth * 0.35);
            const centerHeight = Math.max(4, segmentHeight * 0.9);
            ctx.fillRect(
              Math.round(characterX - centerWidth / 2),
              Math.round(yPos - centerHeight / 2),
              Math.round(centerWidth),
              Math.round(centerHeight)
            );
          }
        }
      }

      // Top fade overlay: taper the road out smoothly near the vanishing point.
      // Draw a vertical gradient from the very top of the canvas to the vanishing point
      // that fades from the background color to transparent. Because the hero GIF
      // sits above the canvas (higher z-index), the fade will not affect the GIF.
      (function drawTopFade() {
        try {
          const fadeTop = 0;
          const fadeBottom = Math.max(0, vanishingPointY); // where the fade becomes fully transparent
          const grad = ctx.createLinearGradient(0, fadeTop, 0, fadeBottom);
          // Use background color at the top and transparent at the vanishing point
          grad.addColorStop(0, colors.bg0);
          grad.addColorStop(1, 'rgba(0,0,0,0)');

          // Save/restore so we don't affect other drawings
          ctx.save();
          ctx.globalCompositeOperation = 'source-over';
          ctx.globalAlpha = 0.7; // less strong so stripes remain visible
          ctx.fillStyle = grad;
          ctx.fillRect(0, fadeTop, canvas.width, fadeBottom);
          ctx.restore();
        } catch (e) {
          // Non-fatal: if gradient drawing fails, ignore and continue
          // console.warn('Top fade draw failed', e);
        }
      })();

      // Removed vignette effect for cleaner animation

      // Continue animation if active
      if (animationActive) {
        requestAnimationFrame(animate);
      } else {
        // Check periodically if we should resume animation
        setTimeout(() => requestAnimationFrame(animate), 500);
      }
    }

    // Start animation
    animate(); // Initial call to start the animation loop

    // Handle resize and scroll
    window.addEventListener('resize', () => {
      resizeCanvas();
      updateRoadSpeed(); // Recalculate speed based on new character size
      initSegments(); // Reset segments with new spacing
    });

    window.addEventListener('scroll', () => {
      checkFooterVisibility(); // Check if footer is visible to adjust animation
    });
  });
</script>

<style>
  .road-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 5; /* Higher so stripes render above page content but below the hero GIF */
    touch-action: none; /* Prevent touch scrolling */
    -webkit-user-select: none; /* Prevent selection */
    user-select: none;
    image-rendering: pixelated; /* Makes road edges crisper */
  }

  /* Create perspective for the hero image with shadow */
  :global(.hero-image) {
    filter: drop-shadow(0 10px 8px rgba(0, 0, 0, 0.5));
    transform-origin: bottom center;
    /* Use much more subtle animation for the GIF */
    animation: snake-move 1s infinite alternate ease-in-out;
    z-index: 20; /* Keep hero above the canvas stripes */
  }

  @keyframes snake-move {
    from { transform: translateY(0); }
    to { transform: translateY(-2px); }
  }

  @media (prefers-reduced-motion: reduce) {
    .road-canvas {
      display: none;
    }

    :global(.hero-image) {
      animation: none;
      filter: none;
    }
  }
</style>
